/*递推法
  将k的所有拆分数按升序排列
  因k的拆分数由3部分组成：
          1)在k-1的所有拆分数中，将各组拆分前加一项1，即得到k的一组拆分数
		  2)若在k-1的拆分数中，存在这样的一组拆分，其第1项小于第2项，则将第1项加1即为k的一组拆分数
		  3)k本身为k的一组拆分
  存储结构：二维数组每行为一组拆分，若k有m组拆分，则占m行，每行中数据个数为这组拆分中拆出数的个数，
            并从下标1开始存储，其中第0号元素存储该行中元素个数，即这组拆分中拆分数的个数。
*/
#include <stdio.h>
void main()
{ int a[700][21],i,j,k,m,n,u;             //定义a[700][21],注意大小，20的拆分数有627组
  m=1;                                    //1的拆分数为一组
  a[0][0]=1;                              //该组拆分中有1个数                        
  a[0][1]=1;                              //拆分数为1
  scanf("%d",&n); 
  if(n==1) {printf("%d:%d\n",n,a[0][1]);return;}   //n=1，直接输出
  for(k=2;k<=n;k++) {                              //n>1，从2开始递推到n
	  u=m;                                         //u为k比k-1拆分组数增加后存储位置
	  for(i=0;i<m;i++) {                           //从k-1的每一组拆分，推k的各组拆分
		  if(a[i][0]>1&&a[i][1]<a[i][2]) {         //若该组拆分中第1项小于第2项，则第1项加1得到k的一组拆分
			  for(j=0;j<=a[i][0];j++)              //存入u指示新增位置
				  a[u][j]=a[i][j];
			  a[u][1]++;                           //第1项加1
			  u++;
		  }
		  for(j=a[i][0];j>0;j--) {                 //将该组拆分中第1项前增加一项1，得到k的一组拆分
			  a[i][j+1]=a[i][j];                   //将k-1拆分各项后移
		  }
		  a[i][1]=1;                               //增加第1项为1
		  a[i][0]++;                               //项数加1
	  }
	  a[u][0]=1;a[u][1]=k;                         //k本身为一组拆分
	  u++;
	  m=u;
  }
  printf("%d: ",k);                                //输出
  for(j=0;j<m;j++) { 
	  for(u=1;u<a[j][0];u++) 
		  printf("%d+",a[j][u]);
	  printf("%d  ",a[j][a[j][0]]);
  }
//  printf("\n%d\n",m);
}